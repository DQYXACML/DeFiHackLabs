// Code generated by integrate_invariants_to_monitor.py - DO NOT EDIT
// Generated at: 2025-10-27T06:30:30.497136
// Source: barleyfinance_invariants.go

package generated

import (
	"autopath/pkg/invariants"
	"autopath/pkg/types"
	"math/big"
	"strings"
)

// BarleyFinanceInvariants 定义了 BarleyFinance 协议的不变量规则
type BarleyFinanceInvariants struct {
	Protocol  string
	Chain     string
	Contracts map[string]string
	Rules     []invariants.InvariantRule
}

// NewBarleyFinanceInvariants 创建 BarleyFinance 不变量配置
func NewBarleyFinanceInvariants() *BarleyFinanceInvariants {
	return &BarleyFinanceInvariants{
		Protocol: "BarleyFinance",
		Chain:    "mainnet",
		Contracts: map[string]string{
			"Attacker":        "0x7b3a6eff1c9925e509c2b01a389238c1fcc462b6",
			"Attack_Contract": "0x356e7481b957be0165d6751a49b4b7194aef18d5",
			"DAI":             "0x6B175474E89094C44Da98b954EedeAC495271d0F",
			"BARL":            "0x3e2324342bF5B8A1Dca42915f0489497203d640E",
			"WETH":            "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
			"wBARL":           "0x04c80Bb477890F3021F03B068238836Ee20aA0b8",
			"Router":          "0xE592427A0AEce92De3Edee1F18E0157C05861564",
		},
		Rules: []invariants.InvariantRule{
			{
				ID:          "inv_001",
				Type:        "balance_change_rate",
				Severity:    "high",
				Description: "攻击者地址余额在单笔交易中增长率不应超过500%",
				Contract:    "",
				Function:    "",
				Threshold:   float64(500),
				Confidence:  0.85,
				Metadata: map[string]interface{}{
					"monitored_address": "0x7b3a6eff1c9925e509c2b01a389238c1fcc462b6",
					"address_type": "attacker",
				},
			},
			{
				ID:          "inv_002",
				Type:        "flash_loan_depth",
				Severity:    "critical",
				Description: "闪电贷嵌套深度不应超过2层",
				Contract:    "",
				Function:    "flash",
				Threshold:   float64(2),
				Confidence:  0.9,
				Metadata: map[string]interface{}{
					"detection_type": "reentrancy_depth",
				},
			},
			{
				ID:          "inv_003",
				Type:        "pool_utilization",
				Severity:    "high",
				Description: "单次闪电贷借出比例不应超过池子总量的95%",
				Contract:    "",
				Function:    "flash",
				Threshold:   float64(95),
				Confidence:  0.8,
				Metadata: map[string]interface{}{
					"metric": "borrow_amount / pool_balance",
				},
			},
			{
				ID:          "inv_004",
				Type:        "call_sequence",
				Severity:    "critical",
				Description: "检测到可疑的重入调用模式（callback → bond/deposit循环）",
				Contract:    "",
				Function:    "",
				Threshold:   float64(2),
				Confidence:  0.85,
				Metadata: map[string]interface{}{
					"pattern": "callback_loop",
					"detection": "reentrancy",
				},
			},
			{
				ID:          "inv_005",
				Type:        "loop_iterations",
				Severity:    "high",
				Description: "检测到大量循环迭代（20次），单笔交易中循环次数不应超过4次",
				Contract:    "",
				Function:    "",
				Threshold:   float64(4),
				Confidence:  0.8,
				Metadata: map[string]interface{}{
					"loop_type": "while",
					"line": "68",
				},
			},
			{
				ID:          "inv_006",
				Type:        "pool_health",
				Severity:    "medium",
				Description: "池子余额不应在单笔交易中下降超过80%",
				Contract:    "",
				Function:    "",
				Threshold:   float64(80),
				Confidence:  0.75,
				Metadata: map[string]interface{}{
					"metric": "pool_balance_drop_percentage",
				},
			},
		},
	}
}

// GetProtocol 实现 Invariants 接口
func (inv *BarleyFinanceInvariants) GetProtocol() string {
	return inv.Protocol
}

// GetChain 实现 Invariants 接口
func (inv *BarleyFinanceInvariants) GetChain() string {
	return inv.Chain
}

// GetContracts 实现 Invariants 接口
func (inv *BarleyFinanceInvariants) GetContracts() map[string]string {
	return inv.Contracts
}

// GetRules 实现 Invariants 接口
func (inv *BarleyFinanceInvariants) GetRules() []invariants.InvariantRule {
	return inv.Rules
}

// Evaluate 评估不变量
func (inv *BarleyFinanceInvariants) Evaluate(txData *types.TransactionData) []types.ViolationDetail {
	violations := []types.ViolationDetail{}

	for _, rule := range inv.Rules {
		violated, detail := inv.evaluateRule(&rule, txData)
		if violated && detail != nil {
			violations = append(violations, *detail)
		}
	}

	return violations
}

// evaluateRule 评估单个规则
func (inv *BarleyFinanceInvariants) evaluateRule(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	switch rule.Type {
	case "call_frequency":
		return inv.checkCallFrequency(rule, txData)
	case "balance_change_rate":
		return inv.checkBalanceChange(rule, txData)
	case "flash_loan_depth":
		return inv.checkFlashLoanDepth(rule, txData)
	case "loop_iterations":
		return inv.checkLoopIterations(rule, txData)
	case "pool_utilization":
		return inv.checkPoolUtilization(rule, txData)
	case "call_sequence":
		return inv.checkCallSequence(rule, txData)
	case "pool_health":
		return inv.checkPoolHealth(rule, txData)
	default:
		return false, nil
	}
}

// checkCallFrequency 检查函数调用频率
func (inv *BarleyFinanceInvariants) checkCallFrequency(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := int(rule.Threshold.(float64))

	// 统计函数调用次数
	callCount := 0
	if rule.Function != "" {
		// 查找包含函数签名的调用
		for funcSig, count := range txData.FunctionCalls {
			if strings.Contains(funcSig, rule.Function) {
				callCount += count
			}
		}
	}

	if callCount > threshold {
		return true, &types.ViolationDetail{
			InvariantID:   rule.ID,
			InvariantType: rule.Type,
			Severity:      rule.Severity,
			Message:       rule.Description,
			Violated:      true,
			Details: map[string]interface{}{
				"threshold":    threshold,
				"actual_calls": callCount,
				"function":     rule.Function,
			},
		}
	}

	return false, nil
}

// checkBalanceChange 检查余额变化率
func (inv *BarleyFinanceInvariants) checkBalanceChange(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := rule.Threshold.(float64)

	// 获取监控地址（如果指定）
	monitoredAddr := ""
	if addrInterface, ok := rule.Metadata["monitored_address"]; ok {
		monitoredAddr = strings.ToLower(addrInterface.(string))
	}

	// 获取关键地址的余额变化
	for addr, change := range txData.BalanceChanges {
		addrLower := strings.ToLower(addr)

		// 如果指定了监控地址，只检查该地址
		if monitoredAddr != "" && addrLower != monitoredAddr {
			continue
		}

		if change.ChangeRate > threshold {
			return true, &types.ViolationDetail{
				InvariantID:   rule.ID,
				InvariantType: rule.Type,
				Severity:      rule.Severity,
				Message:       rule.Description,
				Violated:      true,
				Details: map[string]interface{}{
					"threshold":   threshold,
					"actual_rate": change.ChangeRate,
					"address":     addr,
					"before":      change.Before.String(),
					"after":       change.After.String(),
				},
			}
		}
	}

	return false, nil
}

// checkFlashLoanDepth 检查闪电贷嵌套深度
func (inv *BarleyFinanceInvariants) checkFlashLoanDepth(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := int(rule.Threshold.(float64))

	// 使用ReentrancyDepth作为闪电贷深度的代理指标
	actualDepth := txData.ReentrancyDepth

	if actualDepth > threshold {
		return true, &types.ViolationDetail{
			InvariantID:   rule.ID,
			InvariantType: rule.Type,
			Severity:      rule.Severity,
			Message:       rule.Description,
			Violated:      true,
			Details: map[string]interface{}{
				"threshold":    threshold,
				"actual_depth": actualDepth,
			},
		}
	}

	return false, nil
}

// checkLoopIterations 检查循环迭代次数
func (inv *BarleyFinanceInvariants) checkLoopIterations(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := int(rule.Threshold.(float64))

	if txData.LoopIterations > threshold {
		return true, &types.ViolationDetail{
			InvariantID:   rule.ID,
			InvariantType: rule.Type,
			Severity:      rule.Severity,
			Message:       rule.Description,
			Violated:      true,
			Details: map[string]interface{}{
				"threshold":         threshold,
				"actual_iterations": txData.LoopIterations,
			},
		}
	}

	return false, nil
}

// checkPoolUtilization 检查池子利用率
func (inv *BarleyFinanceInvariants) checkPoolUtilization(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := rule.Threshold.(float64)

	if txData.PoolUtilization > threshold {
		return true, &types.ViolationDetail{
			InvariantID:   rule.ID,
			InvariantType: rule.Type,
			Severity:      rule.Severity,
			Message:       rule.Description,
			Violated:      true,
			Details: map[string]interface{}{
				"threshold":          threshold,
				"actual_utilization": txData.PoolUtilization,
				"pool_address":       txData.PoolAddress,
			},
		}
	}

	return false, nil
}

// checkCallSequence 检查调用序列模式
func (inv *BarleyFinanceInvariants) checkCallSequence(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := int(rule.Threshold.(float64))

	// 检测重入调用模式
	callbackCount := 0
	for _, funcCall := range txData.CallSequence {
		if strings.Contains(strings.ToLower(funcCall), "callback") ||
			strings.Contains(strings.ToLower(funcCall), "bond") ||
			strings.Contains(strings.ToLower(funcCall), "deposit") {
			callbackCount++
		}
	}

	if callbackCount > threshold {
		return true, &types.ViolationDetail{
			InvariantID:   rule.ID,
			InvariantType: rule.Type,
			Severity:      rule.Severity,
			Message:       rule.Description,
			Violated:      true,
			Details: map[string]interface{}{
				"threshold":      threshold,
				"actual_count":   callbackCount,
				"call_sequence":  txData.CallSequence,
				"pattern":        rule.Metadata["pattern"],
			},
		}
	}

	return false, nil
}

// checkPoolHealth 检查池子健康度
func (inv *BarleyFinanceInvariants) checkPoolHealth(rule *invariants.InvariantRule, txData *types.TransactionData) (bool, *types.ViolationDetail) {
	threshold := rule.Threshold.(float64)

	// 从余额变化中计算pool的余额下降百分比
	wBARLAddr := strings.ToLower(inv.Contracts["wBARL"])

	if change, ok := txData.BalanceChanges[wBARLAddr]; ok {
		if change.Before.Cmp(big.NewInt(0)) > 0 {
			// 计算下降百分比
			diff := new(big.Int).Sub(change.Before, change.After)
			if diff.Cmp(big.NewInt(0)) > 0 {
				dropPercentage := float64(diff.Uint64()) / float64(change.Before.Uint64()) * 100

				if dropPercentage > threshold {
					return true, &types.ViolationDetail{
						InvariantID:   rule.ID,
						InvariantType: rule.Type,
						Severity:      rule.Severity,
						Message:       rule.Description,
						Violated:      true,
						Details: map[string]interface{}{
							"threshold":        threshold,
							"actual_drop":      dropPercentage,
							"pool_address":     wBARLAddr,
							"balance_before":   change.Before.String(),
							"balance_after":    change.After.String(),
						},
					}
				}
			}
		}
	}

	return false, nil
}
